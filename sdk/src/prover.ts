/**
 * Proof Generation for Groth16 Circuits
 *
 * This module wraps snarkjs for browser-compatible proof generation.
 *
 * BROWSER CONSTRAINTS:
 * - Must use WASM version of snarkjs
 * - Large circuits (>100K constraints) may timeout
 * - Show progress indicator to user during proof generation
 * - Consider Web Workers for non-blocking proof generation
 */

import type { ProofJson } from './wallet';

/**
 * Witness input for a circuit
 *
 * Keys must match signal names in your circom circuit.
 *
 * EXAMPLE (Transfer Circuit):
 * ```typescript
 * const witnessInput = {
 *     // Public inputs
 *     nullifierHash1: "123...",
 *     nullifierHash2: "456...",
 *     outputCommitment1: "789...",
 *     outputCommitment2: "012...",
 *     root: "345...",
 *     publicDataHash: "678...",
 *
 *     // Private inputs
 *     inNullifier1: "111...",
 *     inSecret1: "222...",
 *     inAmount1: "1000000",
 *     inPathElements1: [...],  // Array of Merkle proof siblings
 *     inPathIndices1: [...],   // Array of path directions
 *     // ... more inputs
 * };
 * ```
 */
export type WitnessInput = Record<string, string | string[] | number[]>;

/**
 * Proof generation result
 */
export interface ProofResult {
    /** Groth16 proof */
    proof: ProofJson;
    /** Public signals (public inputs to circuit) */
    publicSignals: string[];
}

/**
 * Generate a Groth16 proof
 *
 * @param witnessInput - Circuit inputs (public + private)
 * @param wasmPath - Path to circuit WASM file
 * @param zkeyPath - Path to proving key file
 * @returns Proof and public signals
 *
 * FILE REQUIREMENTS:
 * - circuit.wasm: Generated by `circom --wasm`
 * - circuit_final.zkey: Final proving key from trusted setup
 *
 * PERFORMANCE:
 * - Simple circuits (<10K constraints): ~1-2 seconds
 * - Medium circuits (50K constraints): ~5-10 seconds
 * - Complex circuits (>100K constraints): ~30+ seconds
 *
 * EXAMPLE:
 * ```typescript
 * import { groth16 } from 'snarkjs';
 *
 * const { proof, publicSignals } = await generateProof(
 *     witnessInput,
 *     '/circuits/transfer.wasm',
 *     '/circuits/transfer_final.zkey'
 * );
 *
 * // Send to contract
 * await verifyProof(connector, contractId, proof, publicSignals);
 * ```
 */
export async function generateProof(
    witnessInput: WitnessInput,
    wasmPath: string,
    zkeyPath: string
): Promise<ProofResult> {
    // Dynamic import to avoid bundling snarkjs if not used
    const snarkjs = await import('snarkjs');

    console.log('[Prover] Starting proof generation...');
    console.time('[Prover] Proof generation');

    try {
        // Generate witness and proof
        const { proof, publicSignals } = await snarkjs.groth16.fullProve(
            witnessInput,
            wasmPath,
            zkeyPath
        );

        console.timeEnd('[Prover] Proof generation');
        console.log('[Prover] Proof generated successfully');
        console.log('[Prover] Public signals:', publicSignals);

        return { proof, publicSignals };
    } catch (error) {
        console.error('[Prover] Proof generation failed:', error);
        throw new Error(`Proof generation failed: ${error}`);
    }
}

/**
 * Generate proof with progress callback
 *
 * @param witnessInput - Circuit inputs
 * @param wasmPath - Path to circuit WASM
 * @param zkeyPath - Path to proving key
 * @param onProgress - Progress callback (0-100)
 * @returns Proof and public signals
 *
 * EXAMPLE:
 * ```typescript
 * const { proof, publicSignals } = await generateProofWithProgress(
 *     witnessInput,
 *     '/circuits/transfer.wasm',
 *     '/circuits/transfer_final.zkey',
 *     (progress) => {
 *         console.log(`Generating proof... ${progress}%`);
 *         updateProgressBar(progress);
 *     }
 * );
 * ```
 */
export async function generateProofWithProgress(
    witnessInput: WitnessInput,
    wasmPath: string,
    zkeyPath: string,
    onProgress?: (progress: number) => void
): Promise<ProofResult> {
    if (onProgress) onProgress(0);

    const snarkjs = await import('snarkjs');

    if (onProgress) onProgress(10);

    console.log('[Prover] Generating witness...');
    const witness = await snarkjs.wtns.calculate(
        witnessInput,
        wasmPath
    );

    if (onProgress) onProgress(40);

    console.log('[Prover] Generating proof...');
    const { proof, publicSignals } = await snarkjs.groth16.prove(
        zkeyPath,
        witness
    );

    if (onProgress) onProgress(100);

    return { proof, publicSignals };
}

/**
 * Verify a proof locally (before sending to contract)
 *
 * @param proof - Groth16 proof
 * @param publicSignals - Public inputs
 * @param vkPath - Path to verification key JSON
 * @returns true if proof is valid
 *
 * TESTING PATTERN:
 * 1. Generate proof
 * 2. Verify locally (instant, free)
 * 3. If invalid, debug witness inputs
 * 4. Only submit valid proofs to contract
 *
 * This saves gas on invalid proofs!
 */
export async function verifyProofLocally(
    proof: ProofJson,
    publicSignals: string[],
    vkPath: string
): Promise<boolean> {
    const snarkjs = await import('snarkjs');

    // Load verification key
    const vkResponse = await fetch(vkPath);
    const vk = await vkResponse.json();

    // Verify proof
    const isValid = await snarkjs.groth16.verify(vk, publicSignals, proof);

    console.log('[Prover] Local verification:', isValid ? 'VALID' : 'INVALID');

    return isValid;
}

/**
 * Export verification key in NEAR-compatible format
 *
 * @param vkPath - Path to snarkjs verification_key.json
 * @returns VK in format expected by near_groth16_verifier crate
 *
 * USAGE:
 * 1. Generate VK from trusted setup: `snarkjs zkey export verificationkey`
 * 2. Convert to NEAR format: `exportVerificationKey(vkPath)`
 * 3. Initialize contract: `initializeVerifier(connector, contractId, vk)`
 */
export async function exportVerificationKey(vkPath: string): Promise<any> {
    const response = await fetch(vkPath);
    const vk = await response.json();

    // snarkjs format is already compatible with near_groth16_verifier
    // Just validate structure
    if (!vk.protocol || !vk.curve || !vk.nPublic) {
        throw new Error('Invalid verification key format');
    }

    console.log('[Prover] Verification key loaded:', {
        protocol: vk.protocol,
        curve: vk.curve,
        nPublic: vk.nPublic
    });

    return vk;
}
