/**
 * Wallet Integration for NEAR Groth16 Verifier Contracts
 *
 * This module handles wallet connection and transaction formatting for ZK proof verification.
 *
 * CRITICAL LESSONS FROM PRODUCTION:
 * 1. Different wallets expect different action formats
 * 2. HOT Wallet (Meteor) requires explicit signerId
 * 3. Gas/deposit MUST be strings, not BigInt
 * 4. Args MUST be plain objects, not serialized
 *
 * Tested with: HOT Wallet (Meteor), MyNearWallet
 */

import type { NearConnector } from '@hot-labs/near-connect';

/**
 * Groth16 proof in snarkjs JSON format
 *
 * Generated by snarkjs.groth16.fullProve()
 * Format matches circom 2.x output
 */
export interface ProofJson {
    pi_a: [string, string, string];
    pi_b: [[string, string], [string, string], [string, string]];
    pi_c: [string, string, string];
    protocol: string;
    curve: string;
}

/**
 * Create a FunctionCall action in the format expected by @hot-labs/near-connect
 *
 * WHY THIS FORMAT:
 * - The wallet executor expects { type: "FunctionCall", params: {...} }
 * - If you use actionCreators from @near-js/transactions, it breaks
 * - Gas and deposit MUST be strings (wallet converts to BigInt internally)
 * - Args MUST be a plain object (wallet handles serialization)
 */
function createFunctionCallAction(
    methodName: string,
    args: object,
    gas: string,
    deposit: string
) {
    return {
        type: "FunctionCall" as const,
        params: {
            methodName,
            args,
            gas,
            deposit
        }
    };
}

/**
 * Get the signerId from connected wallet
 *
 * WHY THIS IS NEEDED:
 * - HOT Wallet's sandboxed executor requires explicit signerId
 * - Even though the wallet knows who's connected, it won't auto-fill signerId
 * - This was a 3-day debugging nightmare in production
 */
async function getSignerId(wallet: any): Promise<string> {
    const accounts = await wallet.getAccounts();
    const signerId = accounts[0]?.accountId;
    if (!signerId) throw new Error("No account connected");
    return signerId;
}

/**
 * Verify a Groth16 proof on-chain
 *
 * @param connector - NEAR wallet connector (initialized)
 * @param contractId - Verifier contract account ID
 * @param proof - Groth16 proof from snarkjs
 * @param publicInputs - Public signals as decimal strings
 * @param gas - Gas limit (default: 100 TGas, adjust based on circuit complexity)
 *
 * @returns Transaction result with receipt
 *
 * GAS ESTIMATION:
 * - Simple circuits (1-2 inputs): 50-80 TGas
 * - Medium circuits (5 inputs): 80-110 TGas
 * - Complex circuits (10+ inputs): 100-150 TGas
 *
 * EXAMPLE:
 * ```typescript
 * const { proof, publicSignals } = await groth16.fullProve(input, wasm, zkey);
 * const result = await verifyProof(connector, "verifier.near", proof, publicSignals);
 * ```
 */
export async function verifyProof(
    connector: NearConnector,
    contractId: string,
    proof: ProofJson,
    publicInputs: string[],
    gas: string = "100000000000000" // 100 TGas default
): Promise<any> {
    const wallet = await connector.wallet();
    if (!wallet) throw new Error("Wallet not connected");

    // Get signerId - CRITICAL for HOT Wallet compatibility
    const signerId = await getSignerId(wallet);

    const result = await wallet.signAndSendTransaction({
        signerId,          // MUST include for HOT Wallet
        receiverId: contractId,
        actions: [
            createFunctionCallAction(
                "verify_proof",   // Standard method name
                {
                    proof,         // Proof object (wallet serializes)
                    public_inputs: publicInputs
                },
                gas,              // String format
                "0"               // No deposit needed for read-only verification
            )
        ]
    });

    return result;
}

/**
 * Verify proof and execute action (privacy contract pattern)
 *
 * Used when verification triggers state changes (e.g., marking nullifiers spent).
 *
 * @param connector - NEAR wallet connector
 * @param contractId - Privacy contract account ID
 * @param proof - Groth16 proof
 * @param publicInputs - Public signals (first input typically = nullifier)
 * @param deposit - Attached deposit if needed (e.g., storage cost)
 * @param gas - Gas limit (default: 150 TGas for verification + state change)
 *
 * PATTERN:
 * - First public input = nullifier (prevents double-spending)
 * - Second public input = new commitment (optional)
 * - Contract checks nullifier hasn't been used
 * - Contract verifies proof
 * - Contract marks nullifier as spent and adds new commitment
 *
 * EXAMPLE (Private Transfer):
 * ```typescript
 * const publicInputs = [
 *     nullifierHash,      // Spent note nullifier
 *     newCommitment,      // New note commitment
 *     merkleRoot          // Tree root
 * ];
 * await verifyAndRegister(connector, "pool.near", proof, publicInputs);
 * ```
 */
export async function verifyAndRegister(
    connector: NearConnector,
    contractId: string,
    proof: ProofJson,
    publicInputs: string[],
    deposit: string = "0",
    gas: string = "150000000000000" // 150 TGas for verification + storage
): Promise<any> {
    const wallet = await connector.wallet();
    if (!wallet) throw new Error("Wallet not connected");

    const signerId = await getSignerId(wallet);

    const result = await wallet.signAndSendTransaction({
        signerId,
        receiverId: contractId,
        actions: [
            createFunctionCallAction(
                "verify_and_register",  // Privacy contract method
                {
                    proof,
                    public_inputs: publicInputs
                },
                gas,
                deposit
            )
        ]
    });

    return result;
}

/**
 * Initialize a verifier contract with verification key
 *
 * @param connector - NEAR wallet connector
 * @param contractId - Deployed contract account ID
 * @param verificationKey - VK from snarkjs (verification_key.json)
 * @param gas - Gas limit (default: 300 TGas for VK initialization)
 *
 * DEPLOYMENT PATTERN:
 * 1. Deploy contract WASM
 * 2. Call this to initialize with VK
 * 3. Contract is ready to verify proofs
 *
 * WHY SEPARATE INITIALIZATION:
 * - VK is large (~2KB+ serialized)
 * - Can't fit in deploy transaction
 * - Allows VK updates without redeploying contract
 */
export async function initializeVerifier(
    connector: NearConnector,
    contractId: string,
    verificationKey: any,
    gas: string = "300000000000000" // 300 TGas for initialization
): Promise<any> {
    const wallet = await connector.wallet();
    if (!wallet) throw new Error("Wallet not connected");

    const signerId = await getSignerId(wallet);

    const result = await wallet.signAndSendTransaction({
        signerId,
        receiverId: contractId,
        actions: [
            createFunctionCallAction(
                "new",   // Contract initialization method
                {
                    vk: verificationKey
                },
                gas,
                "0"
            )
        ]
    });

    return result;
}

/**
 * Check if a nullifier has been used (view method)
 *
 * @param contractId - Privacy contract account ID
 * @param nullifier - Nullifier hash as decimal string
 * @returns true if nullifier already spent
 *
 * USE CASE:
 * Before generating an expensive proof, check if the note is still unspent.
 * Saves user time and gas if note was already spent.
 */
export async function isNullifierUsed(
    provider: any,  // near-api-js provider
    contractId: string,
    nullifier: string
): Promise<boolean> {
    const result = await provider.query({
        request_type: 'call_function',
        finality: 'final',
        account_id: contractId,
        method_name: 'is_nullifier_used',
        args_base64: Buffer.from(JSON.stringify({ nullifier })).toString('base64')
    });

    return JSON.parse(Buffer.from(result.result).toString());
}

/**
 * Export utilities for custom contract integration
 */
export const utils = {
    createFunctionCallAction,
    getSignerId
};
