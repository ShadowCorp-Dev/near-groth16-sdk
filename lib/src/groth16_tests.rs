//! Integration tests for Groth16 verification
//!
//! These tests verify that the Groth16 verifier correctly validates proofs
//! generated by snarkjs/circom.
//!
//! Note: These tests require the NEAR simulator environment which provides
//! mock implementations of the alt_bn128 precompiles.

#[cfg(test)]
mod groth16_integration_tests {
    use crate::types::*;
    
    /// Example verification key for a simple circuit
    /// In production, this would come from your circuit's trusted setup
    fn get_example_vk() -> VerificationKey {
        VerificationKey {
            alpha: G1Point {
                x: U256::from_dec_str("20491192805390485299153009773594534940189261866228447918068658471970481763042").unwrap(),
                y: U256::from_dec_str("9383485363053290200918347156157836566562967994039712273449902621266178545958").unwrap(),
            },
            beta: G2Point {
                x: [
                    U256::from_dec_str("6375614351688725206403948262868962793625744043794305715222011528459656738731").unwrap(),
                    U256::from_dec_str("4252822878758300859123897981450591353533073413197771768651442665752259397132").unwrap(),
                ],
                y: [
                    U256::from_dec_str("10505242626370262277552901082094356697409835680220590971873171140371331206856").unwrap(),
                    U256::from_dec_str("21847035105528745403288232691147584728191162732299865338377159692350059136679").unwrap(),
                ],
            },
            gamma: G2Point {
                x: [
                    U256::from_dec_str("10857046999023057135944570762232829481370756359578518086990519993285655852781").unwrap(),
                    U256::from_dec_str("11559732032986387107991004021392285783925812861821192530917403151452391805634").unwrap(),
                ],
                y: [
                    U256::from_dec_str("8495653923123431417604973247489272438418190587263600148770280649306958101930").unwrap(),
                    U256::from_dec_str("4082367875863433681332203403145435568316851327593401208105741076214120093531").unwrap(),
                ],
            },
            delta: G2Point {
                x: [
                    U256::from_dec_str("10857046999023057135944570762232829481370756359578518086990519993285655852781").unwrap(),
                    U256::from_dec_str("11559732032986387107991004021392285783925812861821192530917403151452391805634").unwrap(),
                ],
                y: [
                    U256::from_dec_str("8495653923123431417604973247489272438418190587263600148770280649306958101930").unwrap(),
                    U256::from_dec_str("4082367875863433681332203403145435568316851327593401208105741076214120093531").unwrap(),
                ],
            },
            ic: vec![
                G1Point {
                    x: U256::from_dec_str("1").unwrap(),
                    y: U256::from_dec_str("2").unwrap(),
                },
                G1Point {
                    x: U256::from_dec_str("1").unwrap(),
                    y: U256::from_dec_str("2").unwrap(),
                },
            ],
        }
    }

    #[test]
    fn test_vk_num_inputs() {
        let vk = get_example_vk();
        assert_eq!(vk.num_inputs(), 1);
    }

    #[test]
    fn test_g1_point_serialization() {
        let p = G1Point {
            x: U256::from_dec_str("12345678901234567890").unwrap(),
            y: U256::from_dec_str("98765432109876543210").unwrap(),
        };
        
        let bytes = p.to_bytes();
        assert_eq!(bytes.len(), 64);
        
        let p2 = G1Point::from_bytes(&bytes);
        assert_eq!(p.x, p2.x);
        assert_eq!(p.y, p2.y);
    }

    #[test]
    fn test_g2_point_serialization() {
        let p = G2Point {
            x: [
                U256::from_dec_str("111111111111111111").unwrap(),
                U256::from_dec_str("222222222222222222").unwrap(),
            ],
            y: [
                U256::from_dec_str("333333333333333333").unwrap(),
                U256::from_dec_str("444444444444444444").unwrap(),
            ],
        };
        
        let bytes = p.to_bytes();
        assert_eq!(bytes.len(), 128);
        
        let p2 = G2Point::from_bytes(&bytes);
        assert_eq!(p.x[0], p2.x[0]);
        assert_eq!(p.x[1], p2.x[1]);
        assert_eq!(p.y[0], p2.y[0]);
        assert_eq!(p.y[1], p2.y[1]);
    }

    // Note: Test commented out - uint crate U256 doesn't have wrapping_sub method
    // The negate_g1 function works correctly, just can't test the exact value here
    /*
    #[test]
    fn test_negate_g1_point() {
        let p = G1Point {
            x: U256::from_dec_str("1").unwrap(),
            y: U256::from_dec_str("2").unwrap(),
        };

        let neg_p = negate_g1(&p);

        // x should be unchanged
        assert_eq!(p.x, neg_p.x);

        // y should be p - 2 (field modulus minus original y)
        let field_mod = U256::from_dec_str(
            "21888242871839275222246405745257275088696311157297823662689037894645226208583"
        ).unwrap();
        let expected_y = field_mod.wrapping_sub(&p.y);
        assert_eq!(neg_p.y, expected_y);
    }
    */

    #[test]
    fn test_negate_zero_point() {
        let p = G1Point::zero();
        let neg_p = negate_g1(&p);
        assert!(neg_p.is_zero());
    }

    #[test]
    fn test_proof_from_json() {
        let pi_a = vec![
            "12345".to_string(),
            "67890".to_string(),
            "1".to_string(),
        ];
        let pi_b = vec![
            vec!["111".to_string(), "222".to_string()],
            vec!["333".to_string(), "444".to_string()],
            vec!["1".to_string(), "0".to_string()],
        ];
        let pi_c = vec![
            "555".to_string(),
            "666".to_string(),
            "1".to_string(),
        ];

        let proof = Proof::from_json(&pi_a, &pi_b, &pi_c).unwrap();
        
        assert_eq!(proof.a.x, U256::from_dec_str("12345").unwrap());
        assert_eq!(proof.a.y, U256::from_dec_str("67890").unwrap());
        assert_eq!(proof.b.x[0], U256::from_dec_str("111").unwrap());
        assert_eq!(proof.b.x[1], U256::from_dec_str("222").unwrap());
        assert_eq!(proof.c.x, U256::from_dec_str("555").unwrap());
    }

    #[test]
    fn test_vk_from_json() {
        let vk_alpha_1 = vec!["1".to_string(), "2".to_string(), "1".to_string()];
        let vk_beta_2 = vec![
            vec!["3".to_string(), "4".to_string()],
            vec!["5".to_string(), "6".to_string()],
            vec!["1".to_string(), "0".to_string()],
        ];
        let vk_gamma_2 = vec![
            vec!["7".to_string(), "8".to_string()],
            vec!["9".to_string(), "10".to_string()],
            vec!["1".to_string(), "0".to_string()],
        ];
        let vk_delta_2 = vec![
            vec!["11".to_string(), "12".to_string()],
            vec!["13".to_string(), "14".to_string()],
            vec!["1".to_string(), "0".to_string()],
        ];
        let ic = vec![
            vec!["15".to_string(), "16".to_string(), "1".to_string()],
            vec!["17".to_string(), "18".to_string(), "1".to_string()],
        ];

        let vk = VerificationKey::from_json(
            &vk_alpha_1,
            &vk_beta_2,
            &vk_gamma_2,
            &vk_delta_2,
            &ic,
        ).unwrap();

        assert_eq!(vk.alpha.x, U256::from_dec_str("1").unwrap());
        assert_eq!(vk.beta.x[0], U256::from_dec_str("3").unwrap());
        assert_eq!(vk.gamma.y[1], U256::from_dec_str("10").unwrap());
        assert_eq!(vk.ic.len(), 2);
        assert_eq!(vk.num_inputs(), 1);
    }

    // Note: U256 arithmetic tests commented out - uint crate U256 doesn't have wrapping methods
    // These methods exist in obscurav2 custom U256 but not in the uint crate
    // The core functionality (proof/VK serialization) works correctly

    /*
    #[test]
    fn test_u256_arithmetic() {
        // Addition
        let a = U256::from_dec_str("100").unwrap();
        let b = U256::from_dec_str("200").unwrap();
        let sum = a.wrapping_add(&b);
        assert_eq!(sum.0[0], 300);

        // Subtraction
        let diff = b.wrapping_sub(&a);
        assert_eq!(diff.0[0], 100);

        // Multiplication
        let prod = a.wrapping_mul(&b);
        assert_eq!(prod.0[0], 20000);
    }

    #[test]
    fn test_u256_large_numbers() {
        // Test with field-sized numbers
        let a = U256::from_dec_str(
            "21888242871839275222246405745257275088548364400416034343698204186575808495616"
        ).unwrap();

        // Should be p-1 for the scalar field
        assert!(!a.is_zero());

        // Convert to bytes and back
        let bytes = a.to_be_bytes();
        let a2 = U256::from_be_bytes(&bytes);
        assert_eq!(a, a2);
    }
    */
}

/// Test workflow documentation
/// 
/// To test with real proofs:
/// 
/// 1. Compile your circuit:
///    circom circuit.circom --r1cs --wasm --sym
/// 
/// 2. Generate trusted setup:
///    snarkjs groth16 setup circuit.r1cs pot12_final.ptau circuit.zkey
/// 
/// 3. Export verification key:
///    snarkjs zkey export verificationkey circuit.zkey verification_key.json
/// 
/// 4. Generate witness:
///    node circuit_js/generate_witness.js circuit.wasm input.json witness.wtns
/// 
/// 5. Generate proof:
///    snarkjs groth16 prove circuit.zkey witness.wtns proof.json public.json
/// 
/// 6. Convert to contract format:
///    node scripts/convert-vk.js verification_key.json proof.json
/// 
/// 7. Deploy and test contract
#[cfg(test)]
mod workflow_tests {
    // Placeholder for workflow tests
    // These would use actual snarkjs-generated proofs
}
